{"version":3,"sources":["../src/index.ts","index.ts"],"names":[],"mappings":"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","file":"demo.d95cfe16.js","sourceRoot":"../../demo","sourcesContent":["/**\n * Utilites to manipulate the position of elements relative to other elements\n */\n\nexport interface AbsolutePosition {\n\ttop: number;\n\tleft: number;\n\tposition?: AbsolutePosition;\n}\n\nexport type Offset = { top: number, left: number };\n\nexport type ReferenceRect = {\n\theight: number;\n\twidth: number;\n};\n\nexport type Positions = {\n\t[key: string]: (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect) => AbsolutePosition\n};\n\nexport const defaultPositions: Positions = {\n\t\"left\": (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect): AbsolutePosition => ({\n\t\ttop: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n\t\tleft: Math.round(referenceOffset.left - target.offsetWidth)\n\t}),\n\t\"right\": (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect): AbsolutePosition => ({\n\t\ttop: referenceOffset.top - Math.round(target.offsetHeight / 2) + Math.round(referenceRect.height / 2),\n\t\tleft: Math.round(referenceOffset.left + referenceRect.width)\n\t}),\n\t\"top\": (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect): AbsolutePosition => ({\n\t\ttop: Math.round(referenceOffset.top - target.offsetHeight),\n\t\tleft: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n\t}),\n\t\"bottom\": (referenceOffset: Offset, target: HTMLElement, referenceRect: ReferenceRect): AbsolutePosition => ({\n\t\ttop: Math.round(referenceOffset.top + referenceRect.height),\n\t\tleft: referenceOffset.left - Math.round(target.offsetWidth / 2) + Math.round(referenceRect.width / 2)\n\t})\n};\n\nexport default class Position {\n\tprotected positions = defaultPositions;\n\n\tconstructor(positions: Positions = {}) {\n\t\tthis.positions = Object.assign({}, defaultPositions, positions);\n\t}\n\n\tgetRelativeOffset(target: HTMLElement): Offset {\n\t\t// start with the initial element offsets\n\t\tlet offsets = {\n\t\t\tleft: target.offsetLeft,\n\t\t\ttop: target.offsetTop\n\t\t};\n\t\t// get each static (i.e. not absolute or relative) offsetParent and sum the left/right offsets\n\t\twhile (target.offsetParent && getComputedStyle(target.offsetParent).position === \"static\") {\n\t\t\toffsets.left += target.offsetLeft;\n\t\t\toffsets.top += target.offsetTop;\n\t\t\ttarget = target.offsetParent as HTMLElement;\n\t\t}\n\t\treturn offsets;\n\t}\n\n\tgetAbsoluteOffset(target: HTMLElement): Offset {\n\t\tlet currentNode = target;\n\t\tlet margins = {\n\t\t\ttop: 0,\n\t\t\tleft: 0\n\t\t};\n\n\t\t// searches for containing elements with additional margins\n\t\twhile (currentNode.offsetParent) {\n\t\t\tconst computed = getComputedStyle(currentNode.offsetParent);\n\t\t\t// find static elements with additional margins\n\t\t\t// since they tend to throw off our positioning\n\t\t\t// (usually this is just the body)\n\t\t\tif (\n\t\t\t\tcomputed.position === \"static\" &&\n\t\t\t\tcomputed.marginLeft &&\n\t\t\t\tcomputed.marginTop\n\t\t\t) {\n\t\t\t\tif (parseInt(computed.marginTop, 10)) {\n\t\t\t\t\tmargins.top += parseInt(computed.marginTop, 10);\n\t\t\t\t}\n\t\t\t\tif (parseInt(computed.marginLeft, 10)) {\n\t\t\t\t\tmargins.left += parseInt(computed.marginLeft, 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcurrentNode = currentNode.offsetParent as HTMLElement;\n\t\t}\n\n\t\tconst targetRect = target.getBoundingClientRect();\n\t\tconst relativeRect = document.body.getBoundingClientRect();\n\t\treturn {\n\t\t\ttop: targetRect.top - relativeRect.top + margins.top,\n\t\t\tleft: targetRect.left - relativeRect.left + margins.left\n\t\t};\n\t}\n\n\t// finds the position relative to the `reference` element\n\tfindRelative(reference: Element, target: Element, placement: string): AbsolutePosition {\n\t\tconst referenceOffset = this.getRelativeOffset(reference as HTMLElement);\n\t\tconst referenceRect = reference.getBoundingClientRect();\n\t\treturn this.calculatePosition(referenceOffset, referenceRect, target, placement);\n\t}\n\n\tfindAbsolute(reference: Element, target: Element, placement: string): AbsolutePosition {\n\t\tconst referenceOffset = this.getAbsoluteOffset(reference as HTMLElement);\n\t\tconst referenceRect = reference.getBoundingClientRect();\n\t\treturn this.calculatePosition(referenceOffset, referenceRect, target, placement);\n\t}\n\n\tfindPosition(reference: Element,\n\t\ttarget: Element,\n\t\tplacement: string,\n\t\toffsetFunction = this.getAbsoluteOffset): AbsolutePosition {\n\t\tconst referenceOffset = offsetFunction(reference as HTMLElement);\n\t\tconst referenceRect = reference.getBoundingClientRect();\n\t\treturn this.calculatePosition(referenceOffset, referenceRect, target, placement);\n\t}\n\n\tfindPositionAt(offset: Offset, target: Element, placement: string): AbsolutePosition {\n\t\treturn this.calculatePosition(offset, {height: 0, width: 0}, target, placement);\n\t}\n\n\t/**\n\t * Get the dimensions of an element from an AbsolutePosition and a reference element\n\t */\n\tgetPlacementBox(target: HTMLElement, position: AbsolutePosition) {\n\t\tconst targetBottom = target.offsetHeight + position.top;\n\t\tconst targetRight = target.offsetWidth + position.left;\n\n\t\treturn {\n\t\t\ttop: position.top,\n\t\t\tbottom: targetBottom,\n\t\t\tleft: position.left,\n\t\t\tright: targetRight\n\t\t};\n\t}\n\n\taddOffset(position: AbsolutePosition, top = 0, left = 0): AbsolutePosition {\n\t\treturn Object.assign({}, position, {\n\t\t\ttop: position.top + top,\n\t\t\tleft: position.left + left\n\t\t});\n\t}\n\n\tsetElement(element: Element, position: AbsolutePosition): void {\n\t\t(element as HTMLElement).style.top = `${position.top}px`;\n\t\t(element as HTMLElement).style.left = `${position.left}px`;\n\t}\n\n\tfindBestPlacement(reference: Element, target: Element, placements: string[]) {\n\t\t/**\n\t\t * map over the array of placements and weight them based on the percentage of visible area\n\t\t * where visible area is defined as the area not obscured by the window borders\n\t\t */\n\t\tconst weightedPlacements = placements.map(placement => {\n\t\t\tconst pos = this.findPosition(reference, target, placement);\n\t\t\tlet box = this.getPlacementBox((target as HTMLElement), pos);\n\t\t\tlet hiddenHeight = box.bottom - window.innerHeight - window.scrollY;\n\t\t\tlet hiddenWidth = box.right - window.innerWidth - window.scrollX;\n\t\t\t// if the hiddenHeight or hiddenWidth is negative, reset to offsetHeight or offsetWidth\n\t\t\thiddenHeight = hiddenHeight < 0 ? (target as HTMLElement).offsetHeight : hiddenHeight;\n\t\t\thiddenWidth = hiddenWidth < 0 ? (target as HTMLElement).offsetWidth : hiddenWidth;\n\t\t\tconst area = (target as HTMLElement).offsetHeight * (target as HTMLElement).offsetWidth;\n\t\t\tconst hiddenArea = hiddenHeight * hiddenWidth;\n\t\t\tlet visibleArea = area - hiddenArea;\n\t\t\t// if the visibleArea is 0 set it back to area (to calculate the percentage in a useful way)\n\t\t\tvisibleArea = visibleArea === 0 ? area : visibleArea;\n\t\t\tconst visiblePercent = visibleArea / area;\n\t\t\treturn {\n\t\t\t\tplacement,\n\t\t\t\tweight: visiblePercent\n\t\t\t};\n\t\t});\n\n\t\t// sort the placements from best to worst\n\t\tweightedPlacements.sort((a, b) => b.weight - a.weight);\n\t\t// pick the best!\n\t\treturn weightedPlacements[0].placement;\n\t}\n\n\tprotected calculatePosition(\n\t\treferenceOffset: Offset,\n\t\treferenceRect: ReferenceRect,\n\t\ttarget: Element,\n\t\tplacement: string): AbsolutePosition {\n\n\t\tif (this.positions[placement]) {\n\t\t\treturn this.positions[placement](referenceOffset, target as HTMLElement, referenceRect);\n\t\t}\n\t\tconsole.error(\"No function found for placement, defaulting to 0,0\");\n\t\treturn { left: 0, top: 0 };\n\t}\n}\n\nexport const position = new Position();\n","import Position, { position } from \"./../src\";\n\nconst positionDemoElements = (referenceSelector, targetSelector, placement) => {\n\tconst position = new Position();\n\n\tconst reference = document.querySelector(referenceSelector);\n\tconst target = document.querySelector<HTMLElement>(targetSelector);\n\n\tconst pos = position.findPosition(reference, target, placement);\n\n\tposition.setElement(target, pos);\n};\n\npositionDemoElements(\".ref0\", \".tar0\", \"right\");\npositionDemoElements(\".ref1\", \".tar1\", \"right\");\npositionDemoElements(\".ref2\", \".tar2\", \"right\");\npositionDemoElements(\".ref3\", \".tar3\", \"bottom\");\npositionDemoElements(\".ref4\", \".tar4\", \"right\");\npositionDemoElements(\".ref5\", \".tar5\", \"right\");\npositionDemoElements(\".ref6\", \".tar6\", \"right\");\npositionDemoElements(\".ref7\", \".tar7\", \"right\");\n\ndocument.addEventListener(\"click\", (event: MouseEvent) => {\n\tif (document.querySelector<HTMLInputElement>(\".ref8 .demo-enabled\").checked) {\n\t\tconst target = document.querySelector<HTMLElement>(\".tar8\");\n\t\tconst pos = position.findPositionAt({top: event.pageY, left: event.pageX}, target, \"bottom\");\n\n\t\tposition.setElement(target, pos);\n\t}\n});\n\ndocument.addEventListener(\"mousemove\", (event: MouseEvent) => {\n\tif (document.querySelector<HTMLInputElement>(\".ref9 .demo-enabled\").checked) {\n\t\tconst target = document.querySelector<HTMLElement>(\".tar9\");\n\t\tconst pos = position.findPositionAt({ top: event.pageY, left: event.pageX }, target, \"bottom\");\n\n\t\tposition.setElement(target, pos);\n\t}\n});\n\ndocument.addEventListener(\"keydown\", (event: KeyboardEvent) => {\n\tswitch (event.key) {\n\t\tcase \"1\": {\n\t\t\t\tconst input = document.querySelector<HTMLInputElement>(\".ref8 .demo-enabled\");\n\t\t\t\tinput.checked = !input.checked;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tcase \"2\": {\n\t\t\t\tconst input = document.querySelector<HTMLInputElement>(\".ref9 .demo-enabled\");\n\t\t\t\tinput.checked = !input.checked;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n});\n"]}