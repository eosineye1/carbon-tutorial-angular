{"version":3,"file":"table-adapter.class.js","sourceRoot":"","sources":["../src/table/table-adapter.class.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * An abstract class that represents a cell in a table\n */\nexport abstract class TableCellAdapter {\n\t/**\n\t * The index of the cell in the table\n\t */\n\tcellIndex: number;\n\t/**\n\t * The number of columns spanned by this cell\n\t */\n\tcolSpan: number;\n}\n\n/**\n * An abstract class that represents a row in a table\n */\nexport abstract class TableRowAdapter {\n\t/**\n\t * The index of the row in the table\n\t */\n\trowIndex: number;\n\t/**\n\t * An array (or `HTMLCollection`) of `TableCellAdapter`s\n\t */\n\tcells: HTMLCollection | TableCellAdapter[];\n}\n\n/**\n * An abstract representation of a table that provides\n * a standard interface to query 2d tables for cell and row information.\n */\nexport abstract class TableAdapter {\n\t/**\n\t * The last acccessible column in the table\n\t */\n\tpublic get lastColumnIndex(): number { return; }\n\n\t/**\n\t * The last accessible row in the table\n\t */\n\tpublic get lastRowIndex(): number { return; }\n\n\t/**\n\t * Returns a cell from the table\n\t *\n\t * @param row index of the row\n\t * @param column index of the column\n\t */\n\tgetCell(row: number, column: number): TableCellAdapter { return; }\n\n\t/**\n\t * Returns a row from the table\n\t *\n\t * @param row index of the row\n\t */\n\tgetRow(row: number): TableRowAdapter { return; }\n\n\t/**\n\t * Finds the column index of a given cell\n\t *\n\t * @param cell the cell to search for\n\t */\n\tfindColumnIndex(cell: TableCellAdapter): number { return; }\n\n\t/**\n\t * Finds the row index of a given cell\n\t *\n\t * @param cell the cell to search for\n\t */\n\tfindRowIndex(cell: TableCellAdapter): number { return; }\n\n\t/**\n\t * Finds the row and column index of a given cell\n\t *\n\t * @param cell the cell to search for\n\t * @returns a tuple that follows the `[row, column]` convention\n\t */\n\tfindIndex(cell: TableCellAdapter): [number, number] { return; }\n}\n\n/**\n * A concrete implementation of `TableAdapter`\n *\n * Provides standard and consistent access to table cells and rows\n */\nexport class TableDomAdapter implements TableAdapter {\n\t/**\n\t * The last acccessible column in the table\n\t */\n\tpublic get lastColumnIndex() {\n\t\treturn this.tableElement.rows[0].cells.length - 1;\n\t}\n\n\t/**\n\t * The last accessible row in the table\n\t */\n\tpublic get lastRowIndex() {\n\t\treturn this.tableElement.rows.length - 1;\n\t}\n\n\t/**\n\t * `TableDomAdapter` works on a normal HTML table structure.\n\t * Custom tables that don't follow the standard structure should use a custom implementation of `TableAdapter`.\n\t *\n\t * The standard structure allows us to directly query rows for cells and indexes - though we do have to handle colspans specially.\n\t *\n\t * @param tableElement the root HTML table element.\n\t */\n\tconstructor(public tableElement: HTMLTableElement) { }\n\n\t/**\n\t * Returns a cell from the table taking colspans in to account.\n\t *\n\t * @param row index of the row\n\t * @param column index of the column\n\t */\n\tgetCell(row: number, column: number): HTMLTableCellElement {\n\t\tconst baseRow = this.getRow(row);\n\t\tlet baseCells = Array.from(baseRow.cells);\n\n\t\t// rows can have fewer total cells than the actual table\n\t\t// the model pretends all rows behave the same (with colspans > 1 being N cells long)\n\t\t// this maps that view to the HTML view (colspans > 1 are one element, so the array is shorter)\n\t\tlet realIndex = 0;\n\t\t// i is only used for iterating the \"cells\"\n\t\tfor (let i = 0; i < column;) {\n\t\t\t// skip the next N \"cells\"\n\t\t\ti += baseCells[realIndex].colSpan;\n\t\t\t// don't bump realIndex if i now exceeds the column we're shooting for\n\t\t\tif (i > column) { break; }\n\t\t\t// finally, increment realIndex (to keep it generally in step with i)\n\t\t\trealIndex++;\n\t\t}\n\t\treturn baseCells[realIndex];\n\t}\n\n\t/**\n\t * Returns a row from the table\n\t *\n\t * @param row index of the row\n\t */\n\tgetRow(row: number): HTMLTableRowElement {\n\t\treturn this.tableElement.rows[row];\n\t}\n\n\t/**\n\t * Finds the column index of a given cell\n\t *\n\t * @param cell the cell to search for\n\t */\n\tfindColumnIndex(cell: HTMLTableCellElement): number {\n\t\tconst row = this.getRow(this.findRowIndex(cell));\n\t\tlet cellIndex = 0;\n\t\tfor (const c of Array.from(row.cells)) {\n\t\t\tif (c === cell) { break; }\n\t\t\tcellIndex += c.colSpan;\n\t\t}\n\t\treturn cellIndex;\n\t}\n\n\t/**\n\t * Finds the row index of a given cell\n\t *\n\t * @param cell the cell to search for\n\t */\n\tfindRowIndex(cell: HTMLTableCellElement): number {\n\t\tfor (const row of Array.from(this.tableElement.rows)) {\n\t\t\tif (row.contains(cell)) {\n\t\t\t\treturn row.rowIndex;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Finds the row and column index of a given cell\n\t *\n\t * @param cell the cell to search for\n\t * @returns a tuple that follows the `[row, column]` convention\n\t */\n\tfindIndex(cell: HTMLTableCellElement): [number, number] {\n\t\treturn [this.findRowIndex(cell), this.findColumnIndex(cell)];\n\t}\n}\n"]}